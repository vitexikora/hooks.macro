// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Hooks macro › Does not create a double require() with default React import: Does not create a double require() with default React import 1`] = `

import React from 'react';
import { useAutoMemo } from './hooks.macro'

function FakeComponent({ value }) {
  return useAutoMemo(() => value);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';
import React from 'react';

function FakeComponent({ value }) {
  return _useMemo(() => value, [value]);
}


`;

exports[`Hooks macro › Does not create a double require() with named hook import: Does not create a double require() with named hook import 1`] = `

import { useMemo } from 'react';
import { useAutoMemo } from './hooks.macro'

function FakeComponent({ value }) {
  return useAutoMemo(() => value);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';
import { useMemo } from 'react';

function FakeComponent({ value }) {
  return _useMemo(() => value, [value]);
}


`;

exports[`Hooks macro › Doesn’t create duplicate imports: Doesn’t create duplicate imports 1`] = `

import { useAutoMemo } from './hooks.macro';

function FakeComponent() {
  useAutoMemo(12);          
  useAutoMemo(12);          
  useAutoMemo(12);          
  useAutoMemo(12);          
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  _useMemo(() => 12, []);

  _useMemo(() => 12, []);

  _useMemo(() => 12, []);

  _useMemo(() => 12, []);
}


`;

exports[`Hooks macro › Is not confused by block scopes: Is not confused by block scopes 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ propValue = 2 }) {
  const outer = useSomething(3);
  {
    const inner = useSomething(7);
    const result = useAutoMemo(outer * inner * propValue);
  }
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ propValue = 2 }) {
  const outer = useSomething(3);
  {
    const inner = useSomething(7);

    const result = _useMemo(() => outer * inner * propValue, [
      outer,
      inner,
      propValue,
    ]);
  }
}


`;

exports[`Hooks macro › Is not confused by default assignments: Is not confused by default assignments 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ number = 12 }) {
  return useAutoMemo(() => number);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ number = 12 }) {
  return _useMemo(() => number, [number]);
}


`;

exports[`Hooks macro › Is not confused by do expression scopes (with shadowing): Is not confused by do expression scopes (with shadowing) 1`] = `

import { useAutoMemo } from './hooks.macro'

const shadow = 12;
function FakeComponent({ propValue = 2 }) {
  const result = do {
    const shadow = useSomething(7);
    useAutoMemo(shadow * propValue);
  }
  useAutoMemo(shadow * propValue);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';
const shadow = 12;

function FakeComponent({ propValue = 2 }) {
  const result = do {
    const shadow = useSomething(7);

    _useMemo(() => shadow * propValue, [shadow, propValue]);
  };

  _useMemo(() => shadow * propValue, [propValue]);
}


`;

exports[`Hooks macro › Is not confused by do expression scopes: Is not confused by do expression scopes 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ propValue = 2 }) {
  const outer = useSomething(3);
  const result = do {
    const inner = useSomething(7);
    useAutoMemo(outer * inner * propValue);
  }
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ propValue = 2 }) {
  const outer = useSomething(3);
  const result = do {
    const inner = useSomething(7);

    _useMemo(() => outer * inner * propValue, [outer, inner, propValue]);
  };
}


`;

exports[`Hooks macro › Is not confused by indirect recursive functions: Is not confused by indirect recursive functions 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ propValue }) {
  return useAutoMemo(first());
  function first() {
    return propValue > 0 ? second() : propValue + 1;
  }
  function second() {
    return propValue < 0 ? first() : propValue + 2;
  }
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ propValue }) {
  return _useMemo(() => first(), [propValue]);

  function first() {
    return propValue > 0 ? second() : propValue + 1;
  }

  function second() {
    return propValue < 0 ? first() : propValue + 2;
  }
}


`;

exports[`Hooks macro › Is not confused by native JSX tags: Is not confused by native JSX tags 1`] = `

import { useAutoMemo } from './hooks.macro'

const Comp1 = () => null;
const Comp2 = () => null;

function FakeComponent({ prop }) {
  const div = 'hallo';
  const Component = prop ? Comp1 : Comp2;
  return useAutoMemo(<div><Component /></div>);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

const Comp1 = () => null;

const Comp2 = () => null;

function FakeComponent({ prop }) {
  const div = 'hallo';
  const Component = prop ? Comp1 : Comp2;
  return _useMemo(
    () => (
      <div>
        <Component />
      </div>
    ),
    [Component],
  );
}


`;

exports[`Hooks macro › Is not confused by omonims in other block scopes: Is not confused by omonims in other block scopes 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  {
    const inner = useSomething(7);
    const result = useAutoMemo(inner * other);
  }
  {
    const other = useSomething(6);
  }
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  {
    const inner = useSomething(7);

    const result = _useMemo(() => inner * other, [inner]);
  }
  {
    const other = useSomething(6);
  }
}


`;

exports[`Hooks macro › Is not confused by re-assigned known static hooks’ values (default import): Is not confused by re-assigned known static hooks’ values (default import) 1`] = `

import React from 'react';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  let [c, setC] = React.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  useAutoEffect(() => {
    setC(123);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import React from 'react';

function FakeComponent() {
  let [c, setC] = React.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  _useEffect(() => {
    setC(123);
  }, [setC]);
}


`;

exports[`Hooks macro › Is not confused by re-assigned known static hooks’ values (extraneous default import): Is not confused by re-assigned known static hooks’ values (extraneous default import) 1`] = `

import Foo from 'foo';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  let [c, setC] = Foo.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  useAutoEffect(() => {
    setC(123);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import Foo from 'foo';

function FakeComponent() {
  let [c, setC] = Foo.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  _useEffect(() => {
    setC(123);
  }, [setC]);
}


`;

exports[`Hooks macro › Is not confused by re-assigned known static hooks’ values (extraneous global access): Is not confused by re-assigned known static hooks’ values (extraneous global access) 1`] = `

import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  let [c, setC] = Foo.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  useAutoEffect(() => {
    setC(123);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';

function FakeComponent() {
  let [c, setC] = Foo.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  _useEffect(() => {
    setC(123);
  }, [setC]);
}


`;

exports[`Hooks macro › Is not confused by re-assigned known static hooks’ values (global variable access): Is not confused by re-assigned known static hooks’ values (global variable access) 1`] = `

import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  let [c, setC] = React.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  useAutoEffect(() => {
    setC(123);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';

function FakeComponent() {
  let [c, setC] = React.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  _useEffect(() => {
    setC(123);
  }, [setC]);
}


`;

exports[`Hooks macro › Is not confused by re-assigned known static hooks’ values (named import): Is not confused by re-assigned known static hooks’ values (named import) 1`] = `

import { createContext, useCallback, useContext, useEffect, useMemo, useReducer, useRef, useState } from 'react';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  let [c, setC] = useState(0);

  if (c > 4) {
    setC = console.log;
  }

  useAutoEffect(() => {
    setC(123);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useReducer,
  useRef,
  useState,
} from 'react';

function FakeComponent() {
  let [c, setC] = useState(0);

  if (c > 4) {
    setC = console.log;
  }

  _useEffect(() => {
    setC(123);
  }, [setC]);
}


`;

exports[`Hooks macro › Is not confused by re-assigned known static hooks’ values (namespace import): Is not confused by re-assigned known static hooks’ values (namespace import) 1`] = `

import * as React from 'react';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  let [c, setC] = React.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  useAutoEffect(() => {
    setC(123);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import * as React from 'react';

function FakeComponent() {
  let [c, setC] = React.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  _useEffect(() => {
    setC(123);
  }, [setC]);
}


`;

exports[`Hooks macro › Is not confused by re-assigned known static hooks’ values (renamed default import): Is not confused by re-assigned known static hooks’ values (renamed default import) 1`] = `

import Baz from 'react';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  let [c, setC] = Baz.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  useAutoEffect(() => {
    setC(123);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import Baz from 'react';

function FakeComponent() {
  let [c, setC] = Baz.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  _useEffect(() => {
    setC(123);
  }, [setC]);
}


`;

exports[`Hooks macro › Is not confused by re-assigned known static hooks’ values (renamed namespace import): Is not confused by re-assigned known static hooks’ values (renamed namespace import) 1`] = `

import * as Baz from 'react';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  let [c, setC] = Baz.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  useAutoEffect(() => {
    setC(123);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import * as Baz from 'react';

function FakeComponent() {
  let [c, setC] = Baz.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  _useEffect(() => {
    setC(123);
  }, [setC]);
}


`;

exports[`Hooks macro › Is not confused by re-assigned known static hooks’ values (wrong default/namespace import): Is not confused by re-assigned known static hooks’ values (wrong default/namespace import) 1`] = `

import { Foo } from 'react';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  let [c, setC] = Foo.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  useAutoEffect(() => {
    setC(123);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import { Foo } from 'react';

function FakeComponent() {
  let [c, setC] = Foo.useState(0);

  if (c > 4) {
    setC = console.log;
  }

  _useEffect(() => {
    setC(123);
  }, [setC]);
}


`;

exports[`Hooks macro › Is not confused by re-assignments over literal: Is not confused by re-assignments over literal 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  let literal = 3.5;
  literal = Math.random();
  const value = useSomething(12);
  return useAutoMemo(() => literal * value);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  let literal = 3.5;
  literal = Math.random();
  const value = useSomething(12);
  return _useMemo(() => literal * value, [literal, value]);
}


`;

exports[`Hooks macro › Is not confused by re-assignments: Is not confused by re-assignments 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ value }) {
  let fn = () => value;
  fn = 14;
  return useAutoMemo(() => fn());
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ value }) {
  let fn = () => value;

  fn = 14;
  return _useMemo(() => fn(), [fn]);
}


`;

exports[`Hooks macro › Is not confused by self-recursive function (directly called): Is not confused by self-recursive function (directly called) 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ propValue }) {
  return useAutoMemo(fibonacci(propValue));
  function fibonacci(n) {
    return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
  }
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ propValue }) {
  return _useMemo(() => fibonacci(propValue), [propValue]);

  function fibonacci(n) {
    return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
  }
}


`;

exports[`Hooks macro › Is not confused by self-recursive function (indirectly called): Is not confused by self-recursive function (indirectly called) 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ propValue }) {
  return useAutoMemo(calculate());
  function calculate() {
    return fibonacci(propValue);
  }
  function fibonacci(n) {
    return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
  }
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ propValue }) {
  return _useMemo(() => calculate(), [propValue]);

  function calculate() {
    return fibonacci(propValue);
  }

  function fibonacci(n) {
    return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
  }
}


`;

exports[`Hooks macro › Keeps known static hooks’ values (extraneous default import): Keeps known static hooks’ values (extraneous default import) 1`] = `

import Foo from 'foo';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  const ref = Foo.useRef(false);
  const [c, setC] = Foo.useState(0);
  const [s, dispatch] = Foo.useReducer((s, a) => s + a, 0);

  useAutoEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  });

  const handleSomething = useAutoCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  });

  return useAutoMemo(c + s);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import { useCallback as _useCallback } from 'react';
import { useMemo as _useMemo } from 'react';
import Foo from 'foo';

function FakeComponent() {
  const ref = Foo.useRef(false);
  const [c, setC] = Foo.useState(0);
  const [s, dispatch] = Foo.useReducer((s, a) => s + a, 0);

  _useEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  }, [setC, dispatch]);

  const handleSomething = _useCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  }, [setC, s, dispatch, c, ref]);

  return _useMemo(() => c + s, [c, s]);
}


`;

exports[`Hooks macro › Keeps known static hooks’ values (extraneous global access): Keeps known static hooks’ values (extraneous global access) 1`] = `

import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  const ref = Foo.useRef(false);
  const [c, setC] = Foo.useState(0);
  const [s, dispatch] = Foo.useReducer((s, a) => s + a, 0);

  useAutoEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  });

  const handleSomething = useAutoCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  });

  return useAutoMemo(c + s);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import { useCallback as _useCallback } from 'react';
import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const ref = Foo.useRef(false);
  const [c, setC] = Foo.useState(0);
  const [s, dispatch] = Foo.useReducer((s, a) => s + a, 0);

  _useEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  }, [setC, dispatch]);

  const handleSomething = _useCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  }, [setC, s, dispatch, c, ref]);

  return _useMemo(() => c + s, [c, s]);
}


`;

exports[`Hooks macro › Keeps known static hooks’ values (wrong default/namespace import): Keeps known static hooks’ values (wrong default/namespace import) 1`] = `

import { Foo } from 'react';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  const ref = Foo.useRef(false);
  const [c, setC] = Foo.useState(0);
  const [s, dispatch] = Foo.useReducer((s, a) => s + a, 0);

  useAutoEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  });

  const handleSomething = useAutoCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  });

  return useAutoMemo(c + s);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import { useCallback as _useCallback } from 'react';
import { useMemo as _useMemo } from 'react';
import { Foo } from 'react';

function FakeComponent() {
  const ref = Foo.useRef(false);
  const [c, setC] = Foo.useState(0);
  const [s, dispatch] = Foo.useReducer((s, a) => s + a, 0);

  _useEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  }, [setC, dispatch]);

  const handleSomething = _useCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  }, [setC, s, dispatch, c, ref]);

  return _useMemo(() => c + s, [c, s]);
}


`;

exports[`Hooks macro › Keeps other unknown React hooks’ values (default import): Keeps other unknown React hooks’ values (default import) 1`] = `

import React from 'react';
import { useAutoEffect } from './hooks.macro';

const Context = React.createContext(null);

function FakeComponent() {
  const value = React.useContext(Context);

  useAutoEffect(() => {
    console.log(value);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import React from 'react';
const Context = React.createContext(null);

function FakeComponent() {
  const value = React.useContext(Context);

  _useEffect(() => {
    console.log(value);
  }, [value]);
}


`;

exports[`Hooks macro › Keeps other unknown React hooks’ values (extraneous default import): Keeps other unknown React hooks’ values (extraneous default import) 1`] = `

import Foo from 'foo';
import { useAutoEffect } from './hooks.macro';

const Context = Foo.createContext(null);

function FakeComponent() {
  const value = Foo.useContext(Context);

  useAutoEffect(() => {
    console.log(value);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import Foo from 'foo';
const Context = Foo.createContext(null);

function FakeComponent() {
  const value = Foo.useContext(Context);

  _useEffect(() => {
    console.log(value);
  }, [value]);
}


`;

exports[`Hooks macro › Keeps other unknown React hooks’ values (extraneous global access): Keeps other unknown React hooks’ values (extraneous global access) 1`] = `

import { useAutoEffect } from './hooks.macro';

const Context = Foo.createContext(null);

function FakeComponent() {
  const value = Foo.useContext(Context);

  useAutoEffect(() => {
    console.log(value);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
const Context = Foo.createContext(null);

function FakeComponent() {
  const value = Foo.useContext(Context);

  _useEffect(() => {
    console.log(value);
  }, [value]);
}


`;

exports[`Hooks macro › Keeps other unknown React hooks’ values (global variable access): Keeps other unknown React hooks’ values (global variable access) 1`] = `

import { useAutoEffect } from './hooks.macro';

const Context = React.createContext(null);

function FakeComponent() {
  const value = React.useContext(Context);

  useAutoEffect(() => {
    console.log(value);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
const Context = React.createContext(null);

function FakeComponent() {
  const value = React.useContext(Context);

  _useEffect(() => {
    console.log(value);
  }, [value]);
}


`;

exports[`Hooks macro › Keeps other unknown React hooks’ values (named import): Keeps other unknown React hooks’ values (named import) 1`] = `

import { createContext, useCallback, useContext, useEffect, useMemo, useReducer, useRef, useState } from 'react';
import { useAutoEffect } from './hooks.macro';

const Context = createContext(null);

function FakeComponent() {
  const value = useContext(Context);

  useAutoEffect(() => {
    console.log(value);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useReducer,
  useRef,
  useState,
} from 'react';
const Context = createContext(null);

function FakeComponent() {
  const value = useContext(Context);

  _useEffect(() => {
    console.log(value);
  }, [value]);
}


`;

exports[`Hooks macro › Keeps other unknown React hooks’ values (namespace import): Keeps other unknown React hooks’ values (namespace import) 1`] = `

import * as React from 'react';
import { useAutoEffect } from './hooks.macro';

const Context = React.createContext(null);

function FakeComponent() {
  const value = React.useContext(Context);

  useAutoEffect(() => {
    console.log(value);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import * as React from 'react';
const Context = React.createContext(null);

function FakeComponent() {
  const value = React.useContext(Context);

  _useEffect(() => {
    console.log(value);
  }, [value]);
}


`;

exports[`Hooks macro › Keeps other unknown React hooks’ values (renamed default import): Keeps other unknown React hooks’ values (renamed default import) 1`] = `

import Baz from 'react';
import { useAutoEffect } from './hooks.macro';

const Context = Baz.createContext(null);

function FakeComponent() {
  const value = Baz.useContext(Context);

  useAutoEffect(() => {
    console.log(value);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import Baz from 'react';
const Context = Baz.createContext(null);

function FakeComponent() {
  const value = Baz.useContext(Context);

  _useEffect(() => {
    console.log(value);
  }, [value]);
}


`;

exports[`Hooks macro › Keeps other unknown React hooks’ values (renamed namespace import): Keeps other unknown React hooks’ values (renamed namespace import) 1`] = `

import * as Baz from 'react';
import { useAutoEffect } from './hooks.macro';

const Context = Baz.createContext(null);

function FakeComponent() {
  const value = Baz.useContext(Context);

  useAutoEffect(() => {
    console.log(value);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import * as Baz from 'react';
const Context = Baz.createContext(null);

function FakeComponent() {
  const value = Baz.useContext(Context);

  _useEffect(() => {
    console.log(value);
  }, [value]);
}


`;

exports[`Hooks macro › Keeps other unknown React hooks’ values (wrong default/namespace import): Keeps other unknown React hooks’ values (wrong default/namespace import) 1`] = `

import { Foo } from 'react';
import { useAutoEffect } from './hooks.macro';

const Context = Foo.createContext(null);

function FakeComponent() {
  const value = Foo.useContext(Context);

  useAutoEffect(() => {
    console.log(value);
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import { Foo } from 'react';
const Context = Foo.createContext(null);

function FakeComponent() {
  const value = Foo.useContext(Context);

  _useEffect(() => {
    console.log(value);
  }, [value]);
}


`;

exports[`Hooks macro › Skips globals: Skips globals 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const result = useAutoMemo(() => window.innerHeight);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const result = _useMemo(() => window.innerHeight, []);
}


`;

exports[`Hooks macro › Skips immutable constants: Skips immutable constants 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const number = 3.5;
  const string = 'hallo';
  const nullish = null;
  const value = useSomething(12);
  return useAutoMemo(() => [value, number, string, nullish]);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const number = 3.5;
  const string = 'hallo';
  const nullish = null;
  const value = useSomething(12);
  return _useMemo(() => [value, number, string, nullish], [value]);
}


`;

exports[`Hooks macro › Skips internal bindings with omonims: Skips internal bindings with omonims 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const v = useSomething(12);
  const value = [1, 2, 3];
  const result = useAutoMemo(() => value.map(v => v * 2));
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const v = useSomething(12);
  const value = [1, 2, 3];

  const result = _useMemo(() => value.map(v => v * 2), [value]);
}


`;

exports[`Hooks macro › Skips internal bindings: Skips internal bindings 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = [1, 2, 3];
  const result = useAutoMemo(() => value.map(v => v * 2));
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = [1, 2, 3];

  const result = _useMemo(() => value.map(v => v * 2), [value]);
}


`;

exports[`Hooks macro › Skips internal const bindings with omonims: Skips internal const bindings with omonims 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const v = useSomething(12);
  const result = useAutoMemo(() => {
    const v = 42;
    return v;
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const v = useSomething(12);

  const result = _useMemo(() => {
    const v = 42;
    return v;
  }, []);
}


`;

exports[`Hooks macro › Skips internal destructuring bindings with omonims: Skips internal destructuring bindings with omonims 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const v = useSomething(12);
  const value = [1, 2, 3];
  const result = useAutoMemo(() => {
    const [v] = value;
    return v;
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const v = useSomething(12);
  const value = [1, 2, 3];

  const result = _useMemo(() => {
    const [v] = value;
    return v;
  }, [value]);
}


`;

exports[`Hooks macro › Skips known static hooks’ values (default import): Skips known static hooks’ values (default import) 1`] = `

import React from 'react';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  const ref = React.useRef(false);
  const [c, setC] = React.useState(0);
  const [s, dispatch] = React.useReducer((s, a) => s + a, 0);

  useAutoEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  });

  const handleSomething = useAutoCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  });

  return useAutoMemo(c + s);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import { useCallback as _useCallback } from 'react';
import { useMemo as _useMemo } from 'react';
import React from 'react';

function FakeComponent() {
  const ref = React.useRef(false);
  const [c, setC] = React.useState(0);
  const [s, dispatch] = React.useReducer((s, a) => s + a, 0);

  _useEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  }, []);

  const handleSomething = _useCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  }, [s, c]);

  return _useMemo(() => c + s, [c, s]);
}


`;

exports[`Hooks macro › Skips known static hooks’ values (global variable access): Skips known static hooks’ values (global variable access) 1`] = `

import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  const ref = React.useRef(false);
  const [c, setC] = React.useState(0);
  const [s, dispatch] = React.useReducer((s, a) => s + a, 0);

  useAutoEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  });

  const handleSomething = useAutoCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  });

  return useAutoMemo(c + s);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import { useCallback as _useCallback } from 'react';
import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const ref = React.useRef(false);
  const [c, setC] = React.useState(0);
  const [s, dispatch] = React.useReducer((s, a) => s + a, 0);

  _useEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  }, []);

  const handleSomething = _useCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  }, [s, c]);

  return _useMemo(() => c + s, [c, s]);
}


`;

exports[`Hooks macro › Skips known static hooks’ values (named import): Skips known static hooks’ values (named import) 1`] = `

import { createContext, useCallback, useContext, useEffect, useMemo, useReducer, useRef, useState } from 'react';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  const ref = useRef(false);
  const [c, setC] = useState(0);
  const [s, dispatch] = useReducer((s, a) => s + a, 0);

  useAutoEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  });

  const handleSomething = useAutoCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  });

  return useAutoMemo(c + s);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import { useCallback as _useCallback } from 'react';
import { useMemo as _useMemo } from 'react';
import {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useReducer,
  useRef,
  useState,
} from 'react';

function FakeComponent() {
  const ref = useRef(false);
  const [c, setC] = useState(0);
  const [s, dispatch] = useReducer((s, a) => s + a, 0);

  _useEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  }, []);

  const handleSomething = _useCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  }, [s, c]);

  return _useMemo(() => c + s, [c, s]);
}


`;

exports[`Hooks macro › Skips known static hooks’ values (namespace import): Skips known static hooks’ values (namespace import) 1`] = `

import * as React from 'react';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  const ref = React.useRef(false);
  const [c, setC] = React.useState(0);
  const [s, dispatch] = React.useReducer((s, a) => s + a, 0);

  useAutoEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  });

  const handleSomething = useAutoCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  });

  return useAutoMemo(c + s);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import { useCallback as _useCallback } from 'react';
import { useMemo as _useMemo } from 'react';
import * as React from 'react';

function FakeComponent() {
  const ref = React.useRef(false);
  const [c, setC] = React.useState(0);
  const [s, dispatch] = React.useReducer((s, a) => s + a, 0);

  _useEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  }, []);

  const handleSomething = _useCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  }, [s, c]);

  return _useMemo(() => c + s, [c, s]);
}


`;

exports[`Hooks macro › Skips known static hooks’ values (renamed default import): Skips known static hooks’ values (renamed default import) 1`] = `

import Baz from 'react';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  const ref = Baz.useRef(false);
  const [c, setC] = Baz.useState(0);
  const [s, dispatch] = Baz.useReducer((s, a) => s + a, 0);

  useAutoEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  });

  const handleSomething = useAutoCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  });

  return useAutoMemo(c + s);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import { useCallback as _useCallback } from 'react';
import { useMemo as _useMemo } from 'react';
import Baz from 'react';

function FakeComponent() {
  const ref = Baz.useRef(false);
  const [c, setC] = Baz.useState(0);
  const [s, dispatch] = Baz.useReducer((s, a) => s + a, 0);

  _useEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  }, []);

  const handleSomething = _useCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  }, [s, c]);

  return _useMemo(() => c + s, [c, s]);
}


`;

exports[`Hooks macro › Skips known static hooks’ values (renamed namespace import): Skips known static hooks’ values (renamed namespace import) 1`] = `

import * as Baz from 'react';
import { useAutoCallback, useAutoEffect, useAutoMemo } from './hooks.macro';

function FakeComponent() {
  const ref = Baz.useRef(false);
  const [c, setC] = Baz.useState(0);
  const [s, dispatch] = Baz.useReducer((s, a) => s + a, 0);

  useAutoEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  });

  const handleSomething = useAutoCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  });

  return useAutoMemo(c + s);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import { useCallback as _useCallback } from 'react';
import { useMemo as _useMemo } from 'react';
import * as Baz from 'react';

function FakeComponent() {
  const ref = Baz.useRef(false);
  const [c, setC] = Baz.useState(0);
  const [s, dispatch] = Baz.useReducer((s, a) => s + a, 0);

  _useEffect(() => {
    setC(c => c + 1);
    dispatch(41);
  }, []);

  const handleSomething = _useCallback(() => {
    setC(s + 123);
    dispatch(c + 123);
    ref.current = true;
  }, [s, c]);

  return _useMemo(() => c + s, [c, s]);
}


`;

exports[`Hooks macro › Skips numeric constants: Skips numeric constants 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const literal = 3.5;
  const value = useSomething(12);
  return useAutoMemo(() => literal * value);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const literal = 3.5;
  const value = useSomething(12);
  return _useMemo(() => literal * value, [value]);
}


`;

exports[`Hooks macro › Skips out of component bindings: Skips out of component bindings 1`] = `

import { useAutoMemo } from './hooks.macro'

const value = { a: { b: { c: 12 }} };

function FakeComponent() {
  const result = useAutoMemo(() => value.a['b'].c);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';
const value = {
  a: {
    b: {
      c: 12,
    },
  },
};

function FakeComponent() {
  const result = _useMemo(() => value.a['b'].c, []);
}


`;

exports[`Hooks macro › Skips state values with missing setters: Skips state values with missing setters 1`] = `

import React from 'react';
import { useAutoEffect } from './hooks.macro';

function FakeComponent() {
  const [id] = React.useState(Math.random);
  useAutoEffect(() => {
    console.log(id)
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import React from 'react';

function FakeComponent() {
  const [id] = React.useState(Math.random);

  _useEffect(() => {
    console.log(id);
  }, []);
}


`;

exports[`Hooks macro › Skips state values with unused setters: Skips state values with unused setters 1`] = `

import React from 'react';
import { useAutoEffect } from './hooks.macro';

function FakeComponent() {
  const [id, setId] = React.useState(Math.random);
  useAutoEffect(() => {
    console.log(id)
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useEffect as _useEffect } from 'react';
import React from 'react';

function FakeComponent() {
  const [id, setId] = React.useState(Math.random);

  _useEffect(() => {
    console.log(id);
  }, []);
}


`;

exports[`Hooks macro › Works with doubly indirect dependencies on props: Works with doubly indirect dependencies on props 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ getValue }) {
  function getDoubleValue() {
    return getValue() * 2;
  }
  const result = useAutoMemo(() => getDoubleValue());
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ getValue }) {
  function getDoubleValue() {
    return getValue() * 2;
  }

  const result = _useMemo(() => getDoubleValue(), [getValue]);
}


`;

exports[`Hooks macro › Works with doubly indirect dependencies: Works with doubly indirect dependencies 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = useSomething(12);
  function getValue() {
    return value;
  }
  function getDoubleValue() {
    return getValue() * 2;
  }
  const result = useAutoMemo(() => getDoubleValue());
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = useSomething(12);

  function getValue() {
    return value;
  }

  function getDoubleValue() {
    return getValue() * 2;
  }

  const result = _useMemo(() => getDoubleValue(), [value]);
}


`;

exports[`Hooks macro › Works with external obj and conflicting bindings: Works with external obj and conflicting bindings 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const a = useSomething(12);
  const value = { a: { b: { c: 12 }} };
  const result = useAutoMemo(value.a['b'].c);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const a = useSomething(12);
  const value = {
    a: {
      b: {
        c: 12,
      },
    },
  };

  const result = _useMemo(() => value.a['b'].c, [value]);
}


`;

exports[`Hooks macro › Works with external obj returning arrow: Works with external obj returning arrow 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = { a: { b: { c: 12 }} };
  const result = useAutoMemo(() => value.a['b'].c);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = {
    a: {
      b: {
        c: 12,
      },
    },
  };

  const result = _useMemo(() => value.a['b'].c, [value]);
}


`;

exports[`Hooks macro › Works with external obj: Works with external obj 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = { a: { b: { c: 12 }} };
  const result = useAutoMemo(value.a['b'].c);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = {
    a: {
      b: {
        c: 12,
      },
    },
  };

  const result = _useMemo(() => value.a['b'].c, [value]);
}


`;

exports[`Hooks macro › Works with external value returning arrow: Works with external value returning arrow 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = useSomething(12);
  const result = useAutoMemo(() => value);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = useSomething(12);

  const result = _useMemo(() => value, [value]);
}


`;

exports[`Hooks macro › Works with external value: Works with external value 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = useSomething(12);
  const result = useAutoMemo(value);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = useSomething(12);

  const result = _useMemo(() => value, [value]);
}


`;

exports[`Hooks macro › Works with funcs from props, again: Works with funcs from props, again 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ onSomething }) {
  const value = useSomething(12);
  const result = useAutoMemo(() => { onSomething(value) });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ onSomething }) {
  const value = useSomething(12);

  const result = _useMemo(() => {
    onSomething(value);
  }, [onSomething, value]);
}


`;

exports[`Hooks macro › Works with funcs from props: Works with funcs from props 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ onSomething }) {
  const value = useSomething(12);
  const result = useAutoMemo(() => onSomething(value));
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ onSomething }) {
  const value = useSomething(12);

  const result = _useMemo(() => onSomething(value), [onSomething, value]);
}


`;

exports[`Hooks macro › Works with function calls: Works with function calls 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  function callback() {}
  const result = useAutoMemo(() => callback());
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  function callback() {}

  const result = _useMemo(() => callback(), []);
}


`;

exports[`Hooks macro › Works with function expressions: Works with function expressions 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = useSomething(12);
  const result = useAutoMemo(function hallo() {
    return value * 2;
  });
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = useSomething(12);

  const result = _useMemo(
    function hallo() {
      return value * 2;
    },
    [value],
  );
}


`;

exports[`Hooks macro › Works with indirect \`let\` dependencies (arrow with body): Works with indirect \`let\` dependencies (arrow with body) 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = useSomething(12);
  let getDoubleValue = () => {
    return value * 2;
  }
  const result = useAutoMemo(() => getDoubleValue());
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = useSomething(12);

  let getDoubleValue = () => {
    return value * 2;
  };

  const result = _useMemo(() => getDoubleValue(), [value]);
}


`;

exports[`Hooks macro › Works with indirect \`let\` dependencies (arrow with expr): Works with indirect \`let\` dependencies (arrow with expr) 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = useSomething(12);
  let getDoubleValue = () => value * 2;
  const result = useAutoMemo(() => getDoubleValue());
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = useSomething(12);

  let getDoubleValue = () => value * 2;

  const result = _useMemo(() => getDoubleValue(), [value]);
}


`;

exports[`Hooks macro › Works with indirect dependencies (arrow with body): Works with indirect dependencies (arrow with body) 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = useSomething(12);
  const getDoubleValue = () => {
    return value * 2;
  }
  const result = useAutoMemo(() => getDoubleValue());
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = useSomething(12);

  const getDoubleValue = () => {
    return value * 2;
  };

  const result = _useMemo(() => getDoubleValue(), [value]);
}


`;

exports[`Hooks macro › Works with indirect dependencies (arrow with expr): Works with indirect dependencies (arrow with expr) 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = useSomething(12);
  const getDoubleValue = () => value * 2;
  const result = useAutoMemo(() => getDoubleValue());
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = useSomething(12);

  const getDoubleValue = () => value * 2;

  const result = _useMemo(() => getDoubleValue(), [value]);
}


`;

exports[`Hooks macro › Works with indirect dependencies (arrow, without call expression): Works with indirect dependencies (arrow, without call expression) 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ values, whitelist }) {
  const valid = value => whitelist.includes(value);
  const goodValues = useAutoMemo(values.filter(valid));
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ values, whitelist }) {
  const valid = value => whitelist.includes(value);

  const goodValues = _useMemo(() => values.filter(valid), [values, whitelist]);
}


`;

exports[`Hooks macro › Works with indirect dependencies (function declaration): Works with indirect dependencies (function declaration) 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = useSomething(12);
  const result = useAutoMemo(() => getDoubleValue());

  function getDoubleValue() {
    return value * 2;
  }
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = useSomething(12);

  const result = _useMemo(() => getDoubleValue(), [value]);

  function getDoubleValue() {
    return value * 2;
  }
}


`;

exports[`Hooks macro › Works with indirect dependencies (function declaration, without call expression): Works with indirect dependencies (function declaration, without call expression) 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ values, whitelist }) {
  const goodValues = useAutoMemo(values.filter(valid));
  function valid(value) {
    return whitelist.includes(value);
  }
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ values, whitelist }) {
  const goodValues = _useMemo(() => values.filter(valid), [values, whitelist]);

  function valid(value) {
    return whitelist.includes(value);
  }
}


`;

exports[`Hooks macro › Works with indirect dependencies (function expression): Works with indirect dependencies (function expression) 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = useSomething(12);
  const getDoubleValue = function() {
    return value * 2;
  }

  const result = useAutoMemo(() => getDoubleValue());
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = useSomething(12);

  const getDoubleValue = function () {
    return value * 2;
  };

  const result = _useMemo(() => getDoubleValue(), [value]);
}


`;

exports[`Hooks macro › Works with indirect dependencies (function expression, without call expression): Works with indirect dependencies (function expression, without call expression) 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ values, whitelist }) {
  const valid = function valid(value) {
    return whitelist.includes(value);
  };
  const goodValues = useAutoMemo(values.filter(valid));
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ values, whitelist }) {
  const valid = function valid(value) {
    return whitelist.includes(value);
  };

  const goodValues = _useMemo(() => values.filter(valid), [values, whitelist]);
}


`;

exports[`Hooks macro › Works with multiple identical expressions: Works with multiple identical expressions 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const value = useSomething(12);
  const result = useAutoMemo(value * value);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const value = useSomething(12);

  const result = _useMemo(() => value * value, [value]);
}


`;

exports[`Hooks macro › Works with null returning arrow: Works with null returning arrow 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const result = useAutoMemo(() => null);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const result = _useMemo(() => null, []);
}


`;

exports[`Hooks macro › Works with null: Works with null 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent() {
  const result = useAutoMemo(null);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent() {
  const result = _useMemo(() => null, []);
}


`;

exports[`Hooks macro › Works with values from props: Works with values from props 1`] = `

import { useAutoMemo } from './hooks.macro'

function FakeComponent({ propValue }) {
  const result = useAutoMemo(() => propValue);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

function FakeComponent({ propValue }) {
  const result = _useMemo(() => propValue, [propValue]);
}


`;

exports[`Hooks macro › Works with variables used as JSX tags (member access): Works with variables used as JSX tags (member access) 1`] = `

import { useAutoMemo } from './hooks.macro'

const Comp1 = () => null;
const Comp2 = () => null;

function FakeComponent({ prop }) {
  const Config = { component: prop ? Comp1 : Comp2 };
  return useAutoMemo(<Config.component />);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

const Comp1 = () => null;

const Comp2 = () => null;

function FakeComponent({ prop }) {
  const Config = {
    component: prop ? Comp1 : Comp2,
  };
  return _useMemo(() => <Config.component />, [Config]);
}


`;

exports[`Hooks macro › Works with variables used as JSX tags: Works with variables used as JSX tags 1`] = `

import { useAutoMemo } from './hooks.macro'

const Comp1 = () => null;
const Comp2 = () => null;

function FakeComponent({ prop }) {
  const Component = prop ? Comp1 : Comp2;
  return useAutoMemo(<Component />);
}

      ↓ ↓ ↓ ↓ ↓ ↓

import { useMemo as _useMemo } from 'react';

const Comp1 = () => null;

const Comp2 = () => null;

function FakeComponent({ prop }) {
  const Component = prop ? Comp1 : Comp2;
  return _useMemo(() => <Component />, [Component]);
}


`;
